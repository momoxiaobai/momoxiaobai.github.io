<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>小鹿的Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="小鹿的Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小鹿的Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小鹿的Blog">
  
    <link rel="alternate" href="/atom.xml" title="小鹿的Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小鹿的Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-DOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/07/DOM/" class="article-date">
  <time datetime="2017-10-07T13:05:58.000Z" itemprop="datePublished">2017-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/07/DOM/">DOM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="10-1-节点层次"><a href="#10-1-节点层次" class="headerlink" title="10.1 节点层次"></a>10.1 节点层次</h1><p>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。以下面的HTML为例：</p>
<pre><code>&lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Sample Page&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;p&gt;Hello World!&lt;/p&gt;
        &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>文档节点是每个文档的根节点。在上述例子中，文档节点只有一个子节点，即<html>，我们称之为文档节点。</html></p>
<p>文档节点是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。</p>
<h2 id="10-1-1-Node类型"><a href="#10-1-1-Node类型" class="headerlink" title="10.1.1 Node类型"></a>10.1.1 Node类型</h2><p>每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一：</p>
<p>Node.ELEMENT_NODE(1);</p>
<p>Node.ATTRIBUTE_NODE(2);</p>
<p>Node.TEXT_NODE(3);</p>
<p>Node.CDATA_SECTION_NODE(4);</p>
<p>Node.ENTITY_REFERENCE_NODE(5);</p>
<p>Node.ENTITY_NODE(6);</p>
<p>Node.PROCESSING_INSTRUCTION_NODE(7);</p>
<p>Node.COMMENY_NODE(8);</p>
<p>Node.DOCUMENT_NODE(9);</p>
<p>Node.DOCUMENT_TYPE_NODE(10);</p>
<p>Node.DOCUMENT_FRAGMENT_NODE(11);</p>
<p>Node.NOTATION_NODE(12);</p>
<p>为了确保浏览器兼容，最好将nodeType属性与数字值进行比较</p>
<pre><code>if(someNode.nodeType == 1){    //适用于所有浏览器
        alert(&quot;Node is an element&quot;);
}
</code></pre><p><strong>1、nodeName和nodeValue属性</strong></p>
<p>要了解节点的具体信息，可以使用nodeName和nodeValue这两个属性。这两个属性的值完全取决于节点的类型。在使用这两个值以前，最好是先检测下节点的类型</p>
<p>如果节点是一个元素，nodeName中保存的始终都是元素的标签名，而nodeValue的值始终是null。</p>
<p><strong>2、节点关系</strong></p>
<p>文档中所有的节点之间都存在这样或那样的关系。</p>
<p>每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。请注意，虽然可以通过方括号语法来访问NodeList的值，而且这个对象也有length属性，但是它并不是Array的实例。NodeList对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。我们常说，NodeList是有生命、有呼吸的对象，而不是在我们第一次访问它们的某个瞬间摆着的一张快照。</p>
<p>访问保存在NodeList中的节点——可以通过方括号，也可以使用item()方法</p>
<pre><code>var firstChild = someNode.childNodes[0];
var secondChild = someNode.childNodes.item(1);
var count = someNode.childNodes.length;
</code></pre><p>节点间关系图</p>
<p><img src="http://images2017.cnblogs.com/blog/1009007/201708/1009007-20170810153803870-83760900.png" alt=""></p>
<p>hasChildNodes()是一个非常有用的方法。</p>
<p><strong>3、操作节点</strong></p>
<p>（1）appendChild()用于项childNodes列表的末尾添加一个节点。更新完成后，appendChild()返回新增的节点。</p>
<p>var returnedNode = someNode.appendChild(newNode);<br>alert(returnedNode == newNode);          //true<br>alert(someNode.lastChild == newNode);    //true<br>注意：如果传入到appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新的位置。即使可以将DOM树看作是由一系列指针连接起来的，但任何DOM节点也不能同时出现在文档的多个位置上。因此，如果在调用appendChild()时传入了父节点的第一个子节点，那么该节点就会成为父节点的最后一个子节点，</p>
<p>var returnedNode = someNode.appendChild(someNode.firstChild);<br>alert(returnedNode == someNode.firstChild);   //false;<br>alert(returnedNode == someNode.lastChild);   //true;<br>（2）insertBefore()方法，接收两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会编程参照节点的前一个同袍节点，同时被方法返回。如果参照节点是null，则insertBefore()与appendChild()执行相同的操作。</p>
<pre><code>//插入后成为最后一个节点
returnedNode = someNode.insertBefore(newNode,null);
alert(newNode == someNode.lastChild);   //true

//插入后成为第一个节点
returnedNode = someNode.insertBefore(newNode,someNode.firstChild);
alert(returnedNode == newNode);  //true
alert(newNode == some.firstChild); //true

//插入到最后一个子节点的前面

returnedNode = someNode.insertBefore(newNode,someNode.lastChild);
alert(newNode == some.childNodes[someNode.childNodes.length-2]); //true
</code></pre><p>（3）replaceChild()方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除。</p>
<pre><code>//替换第一个子节点
var returnedNode = someNode.replaceChild(newNode,someNode.firstChild);

//替换最后一个节点
var returnedNode = someNode.replaceChild(newNode,someNode.lastChild);
</code></pre><p>（4）removeChild()移除某个节点。接受一个参数，即要移除的节点</p>
<pre><code>//移除第一个节点
var returnedNode = someNode.removeChild(someNode.firstChild);
//移除最后一个节点
var returnedNode = someNode.removeChild(someNode.lastChild);
</code></pre><p>（5）cloneNode()用于创建调用这个方法的节点的一个完全相同的副本。cloneNode()方法接受一个布尔值参数，表示是否执行深复制。在参数为true的情况下，执行深复制，即复制节点及整个子节点树；在参数为false的情况下，执行浅复制，即只复制节点本身。复制后的节点副本属于文档所有，但并没有为它指定父节点。除非通过appendChild()、insertBefore()或replaceChild()将它添加到文档中。</p>
<h2 id="10-1-2-Document类型"><a href="#10-1-2-Document类型" class="headerlink" title="10.1.2 Document类型"></a>10.1.2 Document类型</h2><p>JavaScript通过Document类型表示文档。在浏览器中，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML页面。而且，document对象是window对象的一个属性，因此可以将其作为全局对象来访问。</p>
<p>Document节点具有下列特征：</p>
<p>nodeType的值是9；</p>
<p>nodeName的值为“#document”；</p>
<p>nodeValue的值是null；</p>
<p>parentNode的值为null；</p>
<p>ownerDocument的值为null；</p>
<p><strong>（1）文档的子节点</strong></p>
<p>有两个内置的访问Document节点的子节点快捷方式。第一个就是documentElement属性，该属性始终指向HTML页面中的<html>元素。另一个就是通过childNodes列表访问文档元素，但通过documentElement属性更快捷、更直接。</html></p>
<pre><code>&lt;html&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>这个页面在经过浏览器解析后，其文档中只包含一个子节点，即<html>元素。可以通过documentElement或childNodes列表来访问这个元素</html></p>
<pre><code>var html = document.documentElement; //取得对&lt;html&gt;的引用
alert(html === document.childNodes[0]);  //true
alert(html === document.firstChild);         //true
document对象还有一个body属性，直接指向&lt;body&gt;元素。

var body = document.body;
</code></pre><p>Document的另一个可能的子节点是DocumentType。通常将&lt;!DOCTYPE&gt;标签看成一个与文档其他部分不同的实体，可以通过doctype属性来访问它的信息</p>
<pre><code>var doctype = document.doctype;
</code></pre><p>由于浏览器对document.doctype的支持不一致，因此这个属性的用处很有限。<br><strong>（2）文档信息</strong></p>
<p> 第一个属性是title，包含着<title>元素中的文本——显示在浏览器窗口的标题栏或标签页上。通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏或标签页上。通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。修改title属性的值不会改变<title>元素。</title></title></p>
<pre><code>//取得文档标题
var originalTitle = document.title;

//设置文档标题
document.title = &quot;New page title&quot;;
</code></pre><p>与网页请求有关的3个属性：URL、domain和referrer。URL属性中包含页面完整的URL（即地址栏中显示的URL），domain属性中只包含页面的域名，而referrer属性中则保存着链接到当前页面的那个页面的URL。在没有来源页面的情况下，referrer属性中可能会包含空字符串。所有这些信息都存在于请求的HTTP头部。</p>
<pre><code>//取得完整的URL
var url = document.url;
//取得域名
var domain = document.domain;
//取得来源页面的URL
var url = document.referrer;
</code></pre><p>这三个属性，只有domain是可以设置的。但由于安全考虑，也并非可以给domain设置任何值。如果URL中包含一个子域名，例如p2p.wrox.com，那么就只能将domain设置为“wrox.com”.不能将这个属性设置为URL中不包含的域</p>
<p><strong>（3）查找元素</strong></p>
<p>1、getElementById()，接收一个参数：要取得的元素的ID。</p>
<p>注意：IE8以及低版本不区分ID的大小写，因此“myDiv”和“mydiv”会被当做相同的元素ID。</p>
<p>如果页面中多个元素的ID值相同，getElementById()只返回文档中第一次出现的元素。IE7及较低版本还为此方法添加了一个有意思的“怪癖”：name特性与给定ID匹配的表单元素也会被该方法返回。如果有哪个表单元素的name特性等于指定的ID，而且该元素在文档中位于带有给定ID的冤死前面，那么IE就会返回那个表单元素。</p>
<p><input type="text" name="myElement" value="Text field"></p>
<div id="myElement">A div</div><br>基于上述代码，在IE7中调用document。getElementById(“myElement”)，结果会返回<input>元素；而在其他浏览器中，都会返回对<div>元素的引用。<br><br>2、getElementsByTagName();接收一个参数：即要取得元素的标签名，而返回的是包含零或多个元素的NodeList。<br><br>var images = document.getElementsByTagName(“img”);<br>与NodeList对象类似，可以使用方括号语法或者item()方法来访问HTMLCollection对象中的项。而这个对象中元素的数量则可以通过其length属性取得<br><br>    alert(images.length);  //输出图像的数量<br>    alert(images[0].src);   //输出第一个图像元素的src特性<br>    alert(images.item(0).src);   //输出第一个图像元素的src特性<br>HTMLCollection对象还有一个方法，叫做namedItem()，使用这个方法可以通过元素的name特性取得集合中的项。<br><br>    <img src="myimage.gif" name="myImage"><br>可以通过以下方式从images变量中取得这个<img>元素<br>var myImage = images.namedItem(“myImage”);<br>对命名的项也可以使用方括号语法来访问<br>var myImage = images.namedItem{[“myImage”];<br>可以向getElementsByTagName()中传入“<em>”。在JavaScript及css中，星号（“</em>”）通常表示全部。<br><br>var allElements = document.getElementsByTagName(“*”);包含整个页面的所有元素——按照它们出现的先后顺序。<br><br>3、getElementsByName()这个方法会返回带有给定name特性的所有元素<br><br>4、特殊集合<br><br>document.anchors  包含文档中所有带name特性的<a>元素<br><br>document.forms 包含文档中所有的<form>元素，与document.getElementsByTagName(“form”)得到的结果相同<br><br>document.images 包含文档中所有的<img>元素，与document.getElementsByTagName(“img”)得到的结果相同<br><br>document.links 包含文档中所有带href特性的<a>元素<br><br>## 10.1.3 element类型 ##<br>element类型是web编程中最常见的类型了。element类型用于表现xml或html元素，提供对元素标签名、子节点及特性的访问。<br><br>要访问元素的标签名，可以使用nodename属性，也可以使用tagname属性；这两个属性会返回相同的值。<br><br>    <div id="myDiv"></div>

<pre><code>var div = document.getElementById(&quot;myDiv&quot;);
alert(div.tagName);  //&quot;DIV&quot;
alert(div.tagName == div.nodeName);  //true;
</code></pre><p><strong>1、取得特性</strong><br>每个元素都有一个或多个特性，这些特性的用途是给出相应元素或其内容的附加信息。操作特性的DOM方法有三个：getAttribute()、    setAttribute()、removeAttribute()</p>
<pre><code>var div = document.getElementById(&quot;myDiv&quot;);
alert(div.getAttribute(&quot;id&quot;));  //&quot;myDiv&quot;
alert(div.getAttribute(&quot;class&quot;); // &quot;bd&quot;
</code></pre><p><strong>2、设置特性</strong></p>
<p>与getAttribute()对应的方法是setAttribute()。这个方法接受两个参数：要设置的特性名和值。</p>
<p>div.setAttribute(“id”,”someOtherId”);<br><strong>3、删除特性</strong></p>
<p>removeAttribute()这个方法用于彻底删除元素的特性，调用这个方法不仅会清楚特性的值，而且会从元素中完全删除特性</p>
<pre><code>div.removeAttribute(&quot;class&quot;);
</code></pre><p><strong>4、attributes属性</strong></p>
<pre><code>var id = element.attributes.getNamedItem(&quot;id&quot;).nodeValue;
var id = element.attributes[&quot;id&quot;].nodeValue;
</code></pre><p>用处：</p>
<p>如果想要遍历元素的特性，attributes属性可以使用</p>
<pre><code>for(var i = 0;i &lt; element.attributes.length;i++){
　　attrName = element.attributes[i].nodeName;
　　attrValue = element.attributes[i].nodeValue;
}
</code></pre><p><strong>5、创建元素</strong></p>
<p>document.createElement()可以创建新元素</p>
<p>var div = document.createElement(“div”);<br><strong>6、元素的子节点</strong></p>
<p>使用children、firstElementChild、lastElementChild、nextElementSlibling、parentNode可以取得element元素，避免其他类型节点</p>
<h2 id="10-1-4-文本节点"><a href="#10-1-4-文本节点" class="headerlink" title="10.1.4 文本节点"></a>10.1.4 文本节点</h2><p>文本节点有text类型表示，包含的是可以照字面解释的纯文本内容。</p>
<p><strong>1、创建文本节点</strong></p>
<p>document.createTextNode()创建新文本节点，这个方法接受一个参数，要插入节点中的文本</p>
<p>var element = document.createTextNode(“<strong>Hello</strong>world!”);</p>
<p>var element = document.createTextNode(“Hello world!”);<br><strong>2、规范化文本节点</strong></p>
<p>DOM文档中出现相邻文本节点的情况也不在少数，有一个将相邻文本节点合并的方法，normalize()。如果在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个节点。</p>
<pre><code>var element = document.createElement(&quot;div&quot;);
element.className = &quot;message&quot;;

var textNode = document.createTextNode(&quot;Hello World&quot;);
element.appendChild(textNode);

var anotherTextNode = document.createTextNode(&quot;xiaolu&quot;);
element.appendChild(anotherTextNode);

document.body.appendChild(element):

element.childNodes.length; //2

element.normalize();
element.childNodes.length; //1
</code></pre><p><strong>3、分割文本节点</strong></p>
<pre><code>var element = document.createElement(&quot;div&quot;);
element.className = &quot;message&quot;;

var textNode = document.createTextNode(&quot;Hello World&quot;);
element.appendChild(textNode);

var anotherTextNode = document.createTextNode(&quot;xiaolu&quot;);
element.appendChild(anotherTextNode);

document.body.appendChild(element):

var newNode = element.firstChild.splitText(5);
element.firstChild.nodeValue = &quot;Hello&quot;;
newNode.nodeValue;  //&quot; World&quot;;

element.childNodes.length; //2
</code></pre><h2 id="10-1-8-DocumentFragment类型"><a href="#10-1-8-DocumentFragment类型" class="headerlink" title="10.1.8 DocumentFragment类型"></a>10.1.8 DocumentFragment类型</h2><p>DOM规定文档片段是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。</p>
<p>要创建文档片段，可以使用document.createDocumentFragment();方法</p>
<pre><code>var fragment = document.createDocumentFragment();

var ul = document.createElement(&quot;div&quot;);
var li = null;

for(var i = 0;i &lt; 3;i++){
li = document.createElement(&quot;li&quot;);
li.appendChild(document.createTextNode(&quot;Item &quot;+(i+1)));
frament.appendChild(li);
}

ul.appendChild(fragment);
</code></pre></a></form></a></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/07/DOM/" data-id="cj8hchozg0001w0m6niz4p7j0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-BOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/07/BOM/" class="article-date">
  <time datetime="2017-10-07T12:13:28.000Z" itemprop="datePublished">2017-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/07/BOM/">BOM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>1、窗口位置</strong><br>用来确定和修改window对象位置的属性和方法有很多。IE、Safari、Opera和Chrome都提供了screenLeft和screenTop属性，分别用于表示窗口相对于屏幕左边和上边的位置。FireFox则在screenX和screenY属性中提供相同的窗口位置信息，Safari和Chrome也同时支持者两个属性。跨浏览器取得窗口左边和上边的位置代码：</p>
<pre><code>var leftPos = (typeof window.screenLeft == &quot;number&quot;)?
                        window.screenLeft : window.screenX;
var topPos = (typeof window.screenTop == &quot;number&quot;)?
                        window.screenTop : window.screenY;`
移动窗口

复制代码
//将窗口移动到屏幕左上角
window.moveTo(0,0);

//将窗口向下移动100像素 
window.moveBy(0,100);

//将窗口移动到（200,300）
window.moveTo(200,300);

//将窗口想左移动50像素
window.moveBy(-50,0);
</code></pre><h1 id="2、窗口大小"><a href="#2、窗口大小" class="headerlink" title="2、窗口大小"></a>2、窗口大小</h1><p>IE9+、FireFox、Safari、Opera、Chrome均为此提供了4个属性：innerWidth、innerHeight、outerWidth和outerHeight。</p>
<p>在IE9+、Safari和FireFox中，outerWidth和outerHeight返回浏览器本身的尺寸。在Opera中，这两个属性的值表示页面视图容器的大小，而innerWidth和innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。在Chrome中，outerWidth、outerHeight与innerWidth和innerHeight返回相同的值，即视口大小而非浏览器窗口大小。</p>
<p>在主流浏览器中，document.documentElement.clientWidth和document.documentElement.clientHeight中保存了页面视口的信息。</p>
<p>在IE6中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过document.body.clientWidth和document.body.clientHeight取得相同信息。</p>
<p>取得页面视口的大小代码：</p>
<pre><code>var pageWidth = window.innerWidth,
      pageHeight = window.innerHeight;

if(typeof pageWidth != &quot;number&quot;){

       if(document.compatMode == &quot;CSS1Compat&quot;){
                pageWidth = document.documentElement.clientWidht;
                pageHeight = document.documentElement.clientHeight;
        }else{
                pageWidht = document.body.clientWidht;
                pageHeight = docuemnt.body.clientHeight;
         }
}
</code></pre><p>另外，使用resizeTo()和resizeBy()方法可以调整浏览器窗口的大小。</p>
<pre><code>//调整到100X100
window.resizeTo(100,100);

//调整到200X150
window.resizeBy(100,50);

//调整到300X300
window.resizeTo(300,300);
</code></pre><p>#<br>3、导航和打开窗口 #<br>使用window.open()打开窗口既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。</p>
<p>这个方法可以接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。</p>
<p>如果为window.open()传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或者框架中加载第一个参数指定的URL</p>
<p>//等同于&lt;a href=”http”//www.wrof.com” target=”topFrame”&gt;<br>window.open(“<a href="http://www.wrox.com/&quot;,&quot;topFrame" target="_blank" rel="external">http://www.wrox.com/&quot;,&quot;topFrame</a>“);<br>调用这行代码，就如同用户单击了href属性为<a href="http://www.wrox.com/，target属性为“topFrame”的链接。如果有一个名叫“topFrame”的窗口或者框架，就会在该窗口或框架加载这个URL；否则，就会创建一个新窗口并将其命名为‘topFrame’。此外，第二个参数也可以是下列任何一个特殊的窗口名称：_self、_parent、_top或_blank" target="_blank" rel="external">http://www.wrox.com/，target属性为“topFrame”的链接。如果有一个名叫“topFrame”的窗口或者框架，就会在该窗口或框架加载这个URL；否则，就会创建一个新窗口并将其命名为‘topFrame’。此外，第二个参数也可以是下列任何一个特殊的窗口名称：_self、_parent、_top或_blank</a></p>
<p>#4、系统对话框 #<br>第一种最常用：</p>
<p>alert(“Hello World!”);     通常使用alert()生成警告</p>
<p>第二种：confirm()方法生成；除了确认对话框外，还有一个取消按钮；</p>
<p>例如：confirm(“Are you sure?”);   </p>
<p>confirm()方法会返回布尔值：true表示单击了OK，false表示单击了cancel或者单击了右上角的X按钮</p>
<p>第三种：prompt()方法生成，为一个提示框，用于提示用户输入一些文本。提示框中除了显示OK和Cancel按钮之外，还会显示一个文本输入框，以供用户在其中输入内容。prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）</p>
<p>例如：prompt(“What’s your name?”,”Michael”)</p>
<p>如果用户单击了OK按钮，则prompt()返回文本输入框的值；如果用户单击了Cancel或没有单击OK而是通过其他方式关闭了对话框，则该方法返回null</p>
<h1 id="5、location对象"><a href="#5、location对象" class="headerlink" title="5、location对象"></a>5、location对象</h1><p>window.location和document.location引用的是同一个对象<br>    <html><br>    <body><br>    <table class="table table-bordered table-striped table-condensed"><br>    <tr><td>属性名</td><td>例子</td><td>说明</td></tr><br>    <tr><td>hash</td><td>“#contents”</td><td>返回URL中的hash(#号后跟零或多个字符)，如果URL中不包含散列，则返回空字符串</td></tr><br>    <tr><td>host</td><td>“www.wrox.com:80”</td><td>返回服务器名称和端口号（如果有</td></tr><br>    <tr><td>hostname</td><td>“www.wrox.com”</td><td>返回不带端口号的服务器名称</td></tr><br>    <tr><td>href</td><td>“http:/www.wrox.com”</td><td>返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值</td></tr><br>    <tr><td>pathname</td><td>“/WileyCDA/“</td><td>返回URL中的目录和（或）文件名</td></tr><br>    <tr><td>port</td><td>“8080”</td><td>返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串</td></tr><br>    <tr><td>protocol</td><td>“http:”</td><td>返回页面使用的协议。通常是http:或https:</td></tr><br>    <tr><td>search</td><td>“?q=javascript”</td><td>返回URL的查询字符串。这个字符串以问号开头</td></tr><br>    </table><br>    </body><br>    </html></p>
<p><strong>改变位置</strong></p>
<p>使用location对象可以通过很多方式来改变浏览器的位置。首先，也是为常用的方式，就是使用assign()方法并为其传递一个URL</p>
<p>location.assign(“<a href="http://www.wrox.com" target="_blank" rel="external">http://www.wrox.com</a>“);</p>
<p>如果是将location.href或者window.location设置为一个URL的值，也会以该值调用assign()方法。例如：</p>
<p>window.location = “<a href="http://www.wrox.com" target="_blank" rel="external">http://www.wrox.com</a>“;</p>
<p>location.href = “<a href="http://www.wrox.com" target="_blank" rel="external">http://www.wrox.com</a>“;</p>
<p>最常用的是设置location.href属性。</p>
<h1 id="6、history对象"><a href="#6、history对象" class="headerlink" title="6、history对象"></a>6、history对象</h1><p>1、go()方法：可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向前后者向后跳转的页面数一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）</p>
<p>2、back()和forword()可以模拟浏览器的后退和前进按钮</p>
<p>3、length属性，保存着历史记录的数量</p>
<pre><code>history.go(-1);     //后退一页
history.go(1);      //前进一页
history.go(2);      //前进2页

history.go(&quot;wrox.com&quot;);   //跳转到最近的wrox.com

history.back();    //后退一页
history.forword(); //前进一页
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/07/BOM/" data-id="cj8hchoz20000w0m6hqyw5nfw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript中变量、作用域和内存问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/07/JavaScript中变量、作用域和内存问题/" class="article-date">
  <time datetime="2017-10-07T12:10:10.000Z" itemprop="datePublished">2017-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/07/JavaScript中变量、作用域和内存问题/">JavaScript中变量、作用域和内存问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h1><p>（1）ECMAScript变量肯能包含两种不同的数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，引用类型值指那些可能由多个值构成的对象。</p>
<p>（2）基本数据类型是按值访问，可以操作保存在变量中的实际的值；引用类型的值是保存在内存中对象，操作对象时，实际上是在操作对象的引用而不是实际的对象，引用类型的值是按引用访问的。</p>
<p>（3）传递参数。ECMScript中所有的函数的参数都是按值传递的。</p>
<pre><code>function setName(obj){
     obj.name = &quot;Nicholas&quot;;
     obj = new Object();   //理解为新建一个对象，这个对象和参数obj的值不同，即在堆中地址不同，堆中值也不同，不是同一个对象
     obj.name = &quot;Greg&quot;;   //函数执行完后，新建的obj被销毁。
}

var person = new Object();
setName(person);
alert(person.name);   //&quot;Nicholas&quot;
</code></pre><p>当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p>
<p>（4）instanceof操作符     如果变量时给定引用类型的实例，那么instanceof操作符始终会返回true；如果使用instanceof操作符检测基本类型的值，则操作符始终返回false；因为基本类型不是对象。</p>
<h1 id="二、执行环境及作用域"><a href="#二、执行环境及作用域" class="headerlink" title="二、执行环境及作用域"></a>二、执行环境及作用域</h1><p>（1）执行环境是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。</p>
<p>全局执行环境是最外围的一个执行环境。在web浏览器中，全局执行环境被认为是window对象。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>（2）没有块级作用域</p>
<pre><code>if(true){

   var color = &quot;blue&quot;;
}
alert(color);   //blue;

for(vari = 0; i &lt; 10;i++){
  doSomething(i);

}
alert(i);   //10;
</code></pre><p>对于JavaScript来说，由for语句创建的变量 i 即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。</p>
<h1 id="三、垃圾收集"><a href="#三、垃圾收集" class="headerlink" title="三、垃圾收集"></a>三、垃圾收集</h1><p>（1）JavaScript具有自动垃圾收集机制。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。</p>
<p>JavaScript中<strong>最常用的垃圾收集方式是标记清除</strong>。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量。</p>
<p>另一种不太常见的垃圾收集策略叫做引用计数。</p>
<p>（2）管理内存</p>
<p>JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面考虑，目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。</p>
<p>优化内存占用的最佳方式，就是为执行中的代码值保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用</p>
<p>。这一做法使用于大多数全局变量和全局对象的属性。</p>
<pre><code>function createPerson(name){

     var localPerson = new Object();
     localPerdon.name = name;
     return localPerson;

}

var globalPerson = createPerson(&quot;Nicholas&quot;);

//手工解除globalPerson的引用
globalPerson = null;
</code></pre><p>解除一个值的引用并不意味着自动挥手该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/07/JavaScript中变量、作用域和内存问题/" data-id="cj8hchozn0002w0m6aj0ipaip" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript中离线应用和客户端存储-cookies-sessionStorage-localStorage" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/07/JavaScript中离线应用和客户端存储-cookies-sessionStorage-localStorage/" class="article-date">
  <time datetime="2017-10-07T12:02:52.000Z" itemprop="datePublished">2017-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/07/JavaScript中离线应用和客户端存储-cookies-sessionStorage-localStorage/">JavaScript中离线应用和客户端存储(cookies,sessionStorage,localStorage)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、离线应用"><a href="#一、离线应用" class="headerlink" title="一、离线应用"></a>一、离线应用</h1><p>所谓离线web应用，就是在设备不能上网的情况下仍然可以运行的应用。</p>
<p>开发离线web应用需要几个步骤：首先，确保应用知道设备是否能上网，以便下一步执行正确的操作；然后，应用还必须能访问一定的资源（图像、JavaScript、css等），只有这样才能正常工作；最后，必须有一块本地空间用于保存数据，无论能否上网都不妨碍读写。</p>
<p>##<br>1、离线检测 ##<br>HTML5定义一个navigator.onLine属性，这个属性值为true表示设备能上网，值为false表示设备离线。</p>
<p>除了navigator.onLine属性之外，HTML5还定义了两个事件：online和offline。当网络从离线变为在线或者从在线变为离线时，分别触发这两个事件。</p>
<p>为了检测应用是否离线，在页面加载后，最好先通过navigator.onLine取得初始的状态。然后，就是通过上述两个事件来确定网络连接状态是否变化。当上述事件触发时，navigator.onLine属性的值也会改变，不过必须手工轮询这个属性才能检测到网络状态的变化。</p>
<h2 id="2、应用缓存"><a href="#2、应用缓存" class="headerlink" title="2、应用缓存"></a>2、应用缓存</h2><p>HTML5的应用缓存，或者简称为appcache，是专门为开发离线Web应用而设计的。Appcache就是从浏览器的缓存中分出来的一块缓存区。</p>
<h1 id="二、数据存储"><a href="#二、数据存储" class="headerlink" title="二、数据存储"></a>二、数据存储</h1><p><strong>1、cookie</strong><br><br>是在客户端用于存储会话信息的。该标准要求服务器对任意http请求发送Set-Cookie Http头作为响应头的一部分，其中包括会话信息。</p>
<p>（1）限制</p>
<p>cookie在性质上是绑定在特定的域名下的。当设定了一个cookie后，再创建它的域名发送请求时，都会包含这个cookie。</p>
<p>由于cookie是存在客户端计算机上的，还加入了一些限制确保cookie不会被恶意使用，同时不会占用太多磁盘空间。</p>
<p>1、IE6以及更低版本限制每个域名最多20个cookie</p>
<p>2、IE7和之后版本每个域名最多50个。</p>
<p>3、Firefox限制每个域最多50个cookie。</p>
<p>4、Opera限制每个域最多30个cookie。</p>
<p>5、Safari和Chrome对于每个域的cookie数量限制没有硬性规定。</p>
<p>浏览器中对于cookie的尺寸也有限制。大多数浏览器都有大约4096B（加减1）的长度限制。为了最佳的浏览器兼容性，最好将整个cookie长度限制在4095B（含4095）</p>
<p>以内。</p>
<p><strong>2、IE用户数据</strong><br><br>在IE5.0中，微软通过一个自定义行为引入了持久化用户数据的概念。用户数据允许每个文档最多128KB数据，每个域名最多1MB数据。</p>
<p>复制代码<br>    <div style="behavior:url(#default#userData)" id="dataStore"></div></p>
<pre><code>var dataStore = document.getElementById(&quot;dataStore&quot;);
dataStore.setAttribute(&quot;name&quot;,&quot;xiaolu&quot;);
dataStore.setAttribute(&quot;book&quot;,&quot;javaScript&quot;);
dataStore.save(&quot;BookInfo&quot;);
</code></pre><p>在这段代码中，<div>元素上存入了两部分信息。在用setAttribute()存储数据之后，调用了save()方法，指定了数据空间的名称为BookInfo。下一次页面载入之后，可以使用load()方法指定同样的数据空间名称来获取数据；</div></p>
<pre><code>dataStore.load(&quot;BookInfo&quot;);

alert(dataStore.getAttribute(&quot;name&quot;));  //xiaolu
alert(dataStore.getAttribute(&quot;book&quot;));   //javaScript
</code></pre><p>复制代码<br>可以通过removeAttribute()方法明确指定要删除某元素数据，只要指定属性名称。删除之后，必须要再次调用save()来提交更改。</p>
<pre><code>dataStore.removeAttribute(&quot;name&quot;,&quot;xiaolu&quot;);
dataStore.removeAttribute(&quot;book&quot;,&quot;javaScript&quot;);
dataStore.save(&quot;BookInfo&quot;);
</code></pre><p>对IE用户数据的访问限制和对cookie的限制类似。要访问某个数据空间，脚本运行的页面必须来自同一个域名，在同一个路径下，并使用与进行存储的脚本同样的协议。</p>
<p>和cookie不同的是，你无法将用户数据访问限制扩展到更多的客户。还有一点不同，用户数据默认是可以跨越会话持久存在的，同时也不会过期；数据需要通过removeAttribute()方法专门进行删除以释放空间。</p>
<p>cookie和IE用户数据并非安全，所以不能存放敏感信息。</p>
<h1 id="三、Web存储机制"><a href="#三、Web存储机制" class="headerlink" title="三、Web存储机制"></a>三、Web存储机制</h1><h2 id="1、sessionStorage对象"><a href="#1、sessionStorage对象" class="headerlink" title="1、sessionStorage对象"></a>1、sessionStorage对象</h2><p>sessionStorage对象存储特定于某个会话的数据，也就是该数据只保持到浏览器关闭。</p>
<h2 id="2、localStorage对象"><a href="#2、localStorage对象" class="headerlink" title="2、localStorage对象"></a>2、localStorage对象</h2><p>要访问同一个localStorage对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。数据保留到通过JavaScript删除或者是用户清除浏览器缓存。</p>
<p>限制：对于localStorage而言，大多数桌面浏览器会设置每个来源5MB的限制，Chrome和Safari对每个来源的限制是2.5MB。而iOS版的Safari和Android版的webkit的限制也是2.5MB</p>
<p>对sessionStorage的贤惠也是因浏览器而异。有的浏览器对sessionStorage的大小没有限制，但Chrome、Safari、iOS版Safari和Android版Webkit都有限制，也就是2.5MB。IE8+和Opera对sessionStorage的限制是5MB。</p>
<h2 id="3-indexedDB"><a href="#3-indexedDB" class="headerlink" title="3.indexedDB"></a>3.indexedDB</h2><p>是在浏览器中保存结构化数据的一种数据库。最大特色是使用对象保存数据，而不是使用表来保存数据。</p>
<p><strong>Web storage 和cookie的区别</strong><br><br>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p>
<p>除此之外，Web Storage拥有setItem，getItem，removeItem，clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。<br>但是Cookie是不可或缺的Lcookie的作用是和服务器进行交互，作为HTTP规范的一部分而存在，而Web Storage仅仅是为了在本地“存储”数据而生。</p>
<p>浏览器的支持处理IE7及以下不支持外，其他标准浏览器都完全支持，值得一提的是，IE7、IE6中的userData其实就是JavaScript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持Web Storage</p>
<p>localStorage和sessionStorage都具有相同的操作方法，例如setItem，getItem，removeItem等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/07/JavaScript中离线应用和客户端存储-cookies-sessionStorage-localStorage/" data-id="cj8hchozs0003w0m6xsgdvbyh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-关于自定义check-radio标签样式的方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/07/关于自定义check-radio标签样式的方法/" class="article-date">
  <time datetime="2017-10-07T11:26:14.000Z" itemprop="datePublished">2017-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/07/关于自定义check-radio标签样式的方法/">关于自定义check-radio标签样式的方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="label"><a href="#label" class="headerlink" title="label"></a>label</h1><p>label标签有一个很好的作用就是扩大表单控件元素的点击区域。</p>
<p>一般有两种方法可以达到效果：（1）使用label标签包裹表单控件（2）设置label标签的for属性和表单的id属性一致</p>
<p>这意味着有三种方式可以实现</p>
<pre><code>1 &lt;label for=&quot;checkbox&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; /&gt;

2 &lt;label&gt;&lt;input type=&quot;checkbox&quot;  /&gt;&lt;/label&gt;

3 &lt;label for=&quot;checkbox&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; /&gt;&lt;/label&gt;
</code></pre><p><em>for和id可访问性好于label标签包裹 最好选用第一种方式——-至于原因<a href="http://www.zhangxinxu.com/wordpress/2011/07/%e8%af%b4%e8%af%b4html5%e4%b8%adlabel%e6%a0%87%e7%ad%be%e7%9a%84%e5%8f%af%e8%ae%bf%e9%97%ae%e6%80%a7%e9%97%ae%e9%a2%98/（张鑫旭博客" target="_blank" rel="external">http://www.zhangxinxu.com/wordpress/2011/07/%e8%af%b4%e8%af%b4html5%e4%b8%adlabel%e6%a0%87%e7%ad%be%e7%9a%84%e5%8f%af%e8%ae%bf%e9%97%ae%e6%80%a7%e9%97%ae%e9%a2%98/（张鑫旭博客</a>  说说HTML5中label标签的可访问性问题）</em></p>
<h1 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h1><p>background-position属性设置背景图像的起始位置。</p>
<p>注意对于这个工作在Firefox和Opera，background-attachment必须设置为 “fixed（固定）”</p>
<p><table><br>    <tr><td>默认值:</td><td>0% 0%</td></tr><br>    <tr><td>继承:</td><td>no</td></tr><br>    <tr><td>版本:</td><td>CSS1</td></tr><br>    <tr><td>JavaScript 语法:</td><td>object object.style.backgroundPosition=”center”</td></tr><br></table></p>
<h2 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h2><p><table><br>    <tr><td>值</td><td>描述</td></tr><br>    <tr><td><br>    left top<br><br>    left center<br><br>    left bottom<br><br>    right top<br><br>    right center<br><br>    right bottom<br><br>    center top<br><br>    center center<br><br>    center bottom</td><td>如果仅指定一个关键字，其他值将会是”center”</td></tr><br>    <tr><td>x% y%</td><td>第一个值是水平位置，第二个值是垂直。左上角是0％0％。右下角是100％100％。如果仅指定了一个值，其他值将是50％。 。默认值为：0％0％</td></tr><br>    <tr><td>xpos ypos</td><td>第一个值是水平位置，第二个值是垂直。左上角是0。单位可以是像素（0px0px）或任何其他 CSS单位。如果仅指定了一个值，其他值将是50％。你可以混合使用％和positions</td><br>    </tr><tr><td>inherit</td><td>指定background-position属性设置应该从父元素继承</td><br></tr><br></table><br><img src="http://images2015.cnblogs.com/blog/1009007/201703/1009007-20170305115029329-1490438889.png" alt="">(1057x291)<br>HTML代码：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; /&gt;
&lt;div class=&quot;div&quot;&gt;

&lt;/div&gt;
</code></pre><p>css:</p>
<pre><code>.div{
border:1px solid pink;
width:151px;
height:582px;
background:url(girl.png) no-repeat;
background-position:center;
}
</code></pre><p>效果如下：<br><img src="http://images2015.cnblogs.com/blog/1009007/201703/1009007-20170305162540266-1871320802.png" alt=""></p>
<pre><code>background-position:center top;  
</code></pre><p><img src="http://images2015.cnblogs.com/blog/1009007/201703/1009007-20170305163331923-465583543.png" alt=""></p>
<p>其他效果可以想象；</p>
<p>关于background-position：-xpx,-ypx;</p>
<p>css:</p>
<pre><code>.div{
     border:1px solid pink;
     width:302px;
     height:582px;
     background:url(girl.png) no-repeat;
     background-position:0px 0px;
 }
</code></pre><p>效果：</p>
<p><img src="http://images2015.cnblogs.com/blog/1009007/201703/1009007-20170305164324954-527879923.png" alt=""></p>
<pre><code>background-position：-151px -100px;
</code></pre><p><img src="http://images2015.cnblogs.com/blog/1009007/201703/1009007-20170305164520673-911514049.png" alt="">    </p>
<h1 id="关于checkbox-radio表单自定义样式"><a href="#关于checkbox-radio表单自定义样式" class="headerlink" title="关于checkbox/radio表单自定义样式"></a>关于checkbox/radio表单自定义样式</h1><p>两种方法：</p>
<p>需要将表单元素进行隐藏：display:none;或者visibility：hidden；</p>
<p><1>伪元素法：</1></p>
<p>HTML：</p>
<pre><code>&lt;input type=&quot;radio&quot; id=&quot;radio1&quot; name=&quot;radio&quot; class=&quot;radio&quot; /&gt; &lt;label for=&quot;radio1&quot; &gt; &lt;/label&gt;
 &lt;input type=&quot;checkbox&quot; id=&quot;checkbox1&quot; name=&quot;checkbox1&quot; class=&quot;checkbox&quot;&gt;&lt;label for=&quot;checkbox1&quot;&gt;&lt;/label&gt;
</code></pre><p>css:</p>
<pre><code>/*此处使用了兄弟选择器  在HTML中label标签在input标签的后面*/
.radio+label{
    border-radius: 50%;
    width:16px;
    height: 16px;
    border:1px solid #d9d9d9;
    display: inline-block;
}
.radio:checked+label,.checkbox:checked+label{
    border:1px solid #d73d32;
}
.radio:checked+label:before{
    border-radius: 50%;
    width:8px;
    height:8px;
    line-height: 8px;
    position:relative;
    top:-30%;
    content: &apos;&apos;;
    display: inline-block;
    text-align: center;
    background: #d73d32;
}
.checkbox+label{
    width:16px;
    height:16px;
    border:1px solid #d9d9d9;
    display: inline-block;
}
.checkbox:checked+label:before{
    width:8px;
    height:8px;
    line-height: 8px;
    position:relative;
    top:-25%;
    content: &apos;\2713&apos;; /*使用特殊字符需要加斜杠*/
    color:#d73d32;
    display: inline-block;
    text-align: center;
}
</code></pre><p><2>雪碧图的方法：</2></p>
<p>HTML</p>
<pre><code> &lt;input type=&quot;radio&quot; id=&quot;radio1_sprite&quot; name=&quot;radio&quot; class=&quot;radio_sprite&quot; /&gt; &lt;label for=&quot;radio1_sprite&quot; &gt; &lt;/label&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;checkbox1_sprite&quot; name=&quot;checkbox1&quot; class=&quot;checkbox_sprite&quot;&gt;&lt;label for=&quot;checkbox1_sprite&quot;&gt;&lt;/label&gt;
</code></pre><p>css：</p>
<pre><code>.radio_sprite+label,.checkbox_sprite+label{
    width:16px;
    height:16px;
    background: url(ck/bg.png) no-repeat;
    display: inline-block;
}
.radio_sprite+label{
    background-position: -24px -10px;
}
.radio_sprite:checked+label{
    background-position: -59px -10px;
}
.checkbox_sprite+label{
    background-position: -24px -32px;
}
.checkbox_sprite:checked+label{
    background-position: -59px -32px;
}
</code></pre><p><strong>雪碧图定义：</strong> CSS雪碧 即CSS Sprites，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。</p>
<p>CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非<img>标签。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>减少加载网页图片时对服务器的请求次数</strong></p>
<p>可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量。</p>
<p><strong>提高页面的加载速度</strong></p>
<p>sprite 技术的其中一个好处是图片的加载时间(在有许多 sprite 时，单张图片的加载时间)。由所需图片拼成的一张 GIF 图片的尺寸会明显小于所有图片拼合前的大小。单张的 GIF 只有相关的一个色表，而单独分割的每一张 GIF 都有自己的一个色表，这就增加了总体的大小。因此，单独的一张 JPEG 或者 PNG sprite 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。</p>
<p><strong>减少鼠标滑过的一些bug</strong></p>
<p>IE6不会主动预加载鼠标滑过即a:hover中的背景图片，所以，如果使用多张图片，鼠标滑过会出现闪白的现象。使用CSS雪碧，由于一张图片即可，所以不会出现这种现象。</p>
<p>​## 不足 ##<br><strong>CSS雪碧的最大问题是内存使用</strong></p>
<p>除非这个雪碧图片是被非常小心的组织，你就会最终使用大量的无用的空白。一个例子是来自于WHIT TV的网站。注意这是一个1299×15,000像素的PNG图片。它也被压缩的很好–实际下载大小只有大概26K - 但是浏览器并不会渲染压缩后的图片数据。当这个图片被下载并被解压缩之后，它将占用差不多75MB的内存 (1299 <em> 15000 </em> 4)。如果这个图片并没有使用alpha透明，它将会被优化至1299 <em> 15000 </em> 3，但是要在损失渲染速度的情况下。即使那样，我们也会讨论55MB。这张图片的大部分其实就是空白，那里什么都没有，没有任何有用的内容。只是加载 WHIT主页 就会导致你的浏览器的内存占用上升到至少75+MB，仅仅是因为那一张图片。(PS:遗憾的是，该网站最近已经改版，文中提到的图片已经不存在了)</p>
<p><strong>影响浏览器的缩放功能</strong></p>
<p>如果一个使用CSS雪碧的页面使用一些浏览器提供的整页缩放功能缩放了，浏览器就需要做一些额外的工作来纠正这些图片边缘的行为–基本上来说，是为了避免雪碧中相邻的图片被”露进来”。这对于小图片没有什么问题，但是对于大图片会是一个性能下降。</p>
<p><strong>拼图维护比较麻烦</strong></p>
<p>拼合这么多图片，需要耐心。同时还要时刻思考如何在使用这个图片是不会产生相互的影响。将又瘦又高的图片和又宽又矮的图片放到一起时，不容易操作。如果要修改雪碧中的一个图片，你就要修改整张图片，这无疑会增大工作量。</p>
<p><strong>使CSS的编写变得困难</strong></p>
<p>如果CSS雪碧足够复杂，则大大增加了CSS的代码量和难度，让维护和修改变得困难起来。</p>
<p><strong>CSS雪碧调用的图片不能被打印</strong></p>
<p>CSS 雪碧调用的图片不能被打印，除非在@media中特别添加 print声明。</p>
<p><strong>错误得使用Sprites影响可访问性</strong></p>
<p>一些刚入门的开发人员会为了节省 HTTP 请求数(这是使用 CSS Sprite 一直强调的好处)而把所有的图片都当背景图片来处理 – 甚至是那些传达重要信息的图片。结果会导致一个缺乏可访问性的网站，也会降低 HTML 中 title 和 alt 的潜在益处。</p>
<p>因此，CSS sprite 本身没错，而且也不会引发可访问性问题(事实上，正确得使用会提高可访问性)。但是不分对错的过度使用 sprite 会阻碍具有可访问性和生产率方面的网页建设进程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/07/关于自定义check-radio标签样式的方法/" data-id="cj8hchp0y0009w0m6uh03s785" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-css实现折叠面板" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/07/css实现折叠面板/" class="article-date">
  <time datetime="2017-10-07T08:52:08.000Z" itemprop="datePublished">2017-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/07/css实现折叠面板/">css实现折叠面板</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;使用CSS实现折叠面板&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;input type=&quot;radio&quot; id=&quot;item1&quot; name=&quot;item&quot;&gt;
        &lt;label for=&quot;item1&quot;&gt;Item1&lt;/label&gt;
        &lt;div class=&quot;context hiddenDiv&quot;&gt;
            &lt;span&gt;span123span css html javascript jquery angularJS nodeJS
             css html javascript jquery angularJS nodeJS css html javascript jquery angularJS nodeJS
            &lt;/span&gt;
        &lt;/div&gt;
        &lt;input type=&quot;radio&quot; id=&quot;item2&quot; name=&quot;item&quot;&gt;
        &lt;label for=&quot;item2&quot;&gt;Item2&lt;/label&gt;
        &lt;div class=&quot;context hiddenDiv&quot;&gt;
            &lt;span&gt;
                hello world hello world hello world hello world hello world hello world hello world hello world hello world
                 css html javascript jquery angularJS nodeJS css html javascript jquery angularJS nodeJS css html javascript jquery angularJS nodeJS
                 css html javascript jquery angularJS nodeJS css html javascript jquery angularJS nodeJS
            &lt;/span&gt;
        &lt;/div&gt;
        &lt;input type=&quot;radio&quot; id=&quot;item3&quot; name=&quot;item&quot;&gt;
        &lt;label for=&quot;item3&quot;&gt;Item3&lt;/label&gt;
        &lt;div class=&quot;context hiddenDiv&quot;&gt;
            &lt;span&gt;
                hello world hello world hello world hello world hello world hello world hello world hello world hello world
                 hello world hello world hello world hello world hello world hello world hello world hello world hello world
                   hello world hello world hello world hello world hello world hello world hello world hello world hello world
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>css代码</p>
<pre><code>*{
margin:0;
padding:0;
}
html,body{
    width:100%;
    height:100%;
}
.container{
    width:80%;
    height:400px;
    margin:0 auto;
    margin-top:30px;
    border:1px solid #dddddd;
    border-radius:1px;
}
input{
    display:none;
}
label{
    display:block;
    background-color: #F5F5F5;
    width:99%;
    height:40px;
    margin:0 auto;
    border:1px solid #dddddd;
    border-radius:2px;
    margin-top:5px;
    line-height: 40px;
}
.context{
    width:99%;
    height:0px;
    margin:0 auto;
    border:1px solid #dddddd;
    border-radius:2px;
    visibility: hidden;
    transition:height 0.5s linear;
    -webkit-transition:height 0.5s linear;
    -moz-transition:height 0.5s linear;
    -ms-transition:height 0.5s linear;
}
input:checked + label + .context{
    visibility: visible;
    height:150px;
}
</code></pre><p>1、处理折叠和展开的动画效果时候，使用transition（过渡效果），开始隐藏div时候使用了display：none;  transition没有效果，因为视图中已经没有div的物理位置，重新block后，回流和渲染，而visbility：hidden还保留其物理位置，只需要渲染就可以，transition起作用，记得以前做东西时候，经常会遇到相似的问题，但是，可能对display先入为主，总是先想到这个小玩意去隐藏元素，display会影响transition的效果，dom元素要在视图中有位置，才能进行一系列动画效果，注意这一点。</p>
<p>2、处理div时候用到了兄弟选择器，经试验，可以使用多个“+”选择兄弟的兄弟等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/07/css实现折叠面板/" data-id="cj8hchp060005w0m66ix2vi4z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-理解e-clientX-e-pageX-e-offsetX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/07/理解e-clientX-e-pageX-e-offsetX/" class="article-date">
  <time datetime="2017-10-07T07:31:49.000Z" itemprop="datePublished">2017-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/07/理解e-clientX-e-pageX-e-offsetX/">理解e.clientX,e.pageX,e.offsetX</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>event.clientX、event.clientY</p>
<p>鼠标相对于浏览器窗口可视区域的X，Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。IE事件和标准事件都定义了这2个属性</p>
<p>event.pageX、event.pageY</p>
<p>类似于event.clientX、event.clientY，但它们使用的是文档坐标而非窗口坐标。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。</p>
<p>event.offsetX、event.offsetY</p>
<p>鼠标相对于事件源元素（srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性。</p>
<p>event.screenX、event.screenY</p>
<p>鼠标相对于用户显示器屏幕左上角的X,Y坐标。标准事件和IE事件都定义了这2个属性<br><img src="http://images2015.cnblogs.com/blog/1009007/201702/1009007-20170223112832882-336762012.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/07/理解e-clientX-e-pageX-e-offsetX/" data-id="cj8hchp0u0008w0m6upvei298" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/01/hello-blog/" class="article-date">
  <time datetime="2017-10-01T02:48:58.000Z" itemprop="datePublished">2017-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/01/hello-blog/">hello blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>三只单身狗的国庆</strong></p>
<hr>
<p>一推实验室的门，竟然还没有人来，果然国庆一天，迎接我们的是一室的阳光。没有人气的实验室，只有七条小鱼在等着喂食。略凄惨略凄惨，自拍几张发个圈心情就会好一点吗？答案是：那当然。于是就有了这样一条朋友圈，含泪祝福祖国妈妈生日快乐。<br><img src="http://images2017.cnblogs.com/blog/1009007/201710/1009007-20171007165057896-643820112.jpg" alt=""><br><img src="http://images2017.cnblogs.com/blog/1009007/201710/1009007-20171007165038068-1858583719.jpg" alt=""><br><img src="http://images2017.cnblogs.com/blog/1009007/201710/1009007-20171007165050958-2005071693.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/01/hello-blog/" data-id="cj8hchozx0004w0m6xv0ge581" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/github/">github</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/01/hello-world/" class="article-date">
  <time datetime="2017-10-01T02:24:33.132Z" itemprop="datePublished">2017-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/01/hello-world/" data-id="cj8hchp0p0007w0m6fedbm5eg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/07/DOM/">DOM</a>
          </li>
        
          <li>
            <a href="/2017/10/07/BOM/">BOM</a>
          </li>
        
          <li>
            <a href="/2017/10/07/JavaScript中变量、作用域和内存问题/">JavaScript中变量、作用域和内存问题</a>
          </li>
        
          <li>
            <a href="/2017/10/07/JavaScript中离线应用和客户端存储-cookies-sessionStorage-localStorage/">JavaScript中离线应用和客户端存储(cookies,sessionStorage,localStorage)</a>
          </li>
        
          <li>
            <a href="/2017/10/07/关于自定义check-radio标签样式的方法/">关于自定义check-radio标签样式的方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>